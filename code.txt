1. Loop Detection: "cycle", "linked list", "loop detection" 36
2. Bitonic Doubly Linked List Sorting: "bitonic", "sort", "doubly linked list" 111
3. Segregating Even and Odd Nodes: "segregate", "even", "odd", "linked list" 184
4. Merge Sort for DLL: "merge sort", "doubly linked list" 256
5. Minimum Stack: "minimum", "stack" 338
6. Celebrity Problem: "celebrity", "problem" 402
7. Tower of Hanoi: "Tower of Hanoi", "stacks" 452				
8. Stock Span Problem: "stock span", "problem" 530
9. Priority Queue using DLL: "priority queue", "doubly linked list" 561
10. Sort Without Extra Space: "sort", "queue", "no extra space" 632
11. Max Sliding Window: "maximum", "sliding window" 691
12. Stack Permutation: "stack", "permutation" 725
13. Recover BST: "recover", "binary search tree", "BST" 758
14. Views of Tree: "view", "binary tree", "right", "left", "top", "bottom" 802
15. Vertical Order Traversal: "vertical order", "traversal", "binary tree" 951
16. BOUNDARY TRAVERSAL: "left boundry", "traversal", "binary tree" 1030
17. K-ARY HEAP: "k-children" 1122
18. Winning Tree: "sorting purpose", "find largest smallest element", "m-way merges", "Truck Loading problem", " median of N-sorted arrays" 1206
19. HEAP SORT: "sorting large dataset" 1275
20. Topology Order | Topology SORT: "completion of one task depends upon the completion of several other tasks" 1317
21. DIALS ALGORITM: "small range weights" 1389
22. BELLMAN FORD ALGORITM "sortest path", "negative" 1495
23. BINOMIAL HEAP:1599
24. BFS{Breadth first search}: "pathfinding", "connected components", "shortest path problems" 1844
25. Hashmap to treemap: 1889
26. Hashset Treeset LinkedlistHashSet:"set" "hashcode" "doubly linked list" "sortedSet" 1955
27. Distributing items to a person: 2044
28. Fibonacci: "each no. sum of prev no" 2092
29. Longest Common Subsequence: "common" 2134
30. Longest Increasing Subsequence: "array" "increasing" 2157
31. Longest Bitonic Subsequence: "increase then decrease" 2185
32. Longest Palindromic Subsequence: "max length" "Palindrome" 2218
33. Subset Sum problem: "subset", "set", "sum" 2241


// 1. Loop Detection
import java.util.*;
class Node {
    int num;
    Node next;
    Node(int val) {
        num = val;
        next = null; 
    }  
}
class Main {
    static Node insertNode(Node head, int val) {
        Node newNode = new Node(val);
        if (head == null) {
            head = newNode;
            return head;
        }
        Node temp = head;
        while (temp.next != null)
            temp = temp.next;
        temp.next = newNode;
        return head;
    }
    static void display(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.num + "->");
            temp = temp.next;
        }
        System.out.println("NULL");
    }
    static void createCycle(Node head, int a, int b) {
        Node p1 = head;
        Node p2 = head;
        for (int cnta = 0; p1 != null && cnta < a; cnta++) {
            p1 = p1.next;
        }
        for (int cntb = 0; p2 != null && cntb < b; cntb++) {
            p2 = p2.next;
        }
        if (p1 != null && p2 != null) {
            p2.next = p1;
        }
    }
    static boolean cycleDetect(Node head) {
        if (head == null) return false;
        Node fast = head;
        Node slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) return true;
        }
        return false;
    }
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Node head = null;
        for (int i = 0; i < n; i++) {
            int m = sc.nextInt();
            head = insertNode(head, m);
        }
        display(head);
        int a = sc.nextInt();
        int b = sc.nextInt(); 
        createCycle(head, 1, a); 
        if (cycleDetect(head))
            System.out.println("Cycle detected");
        else
            System.out.println("Cycle not detected");
        sc.close();
    }
}

// 2. Sort the bitonic dll
import java.util.*;
class Main {
    static class Node {
        int data; 
        Node next;
        Node prev;
    }
    static Node sort(Node head) {
        if (head == null || head.next == null)
            return head;
        Node front = head;
        Node last = head;
        Node res = new Node();
        Node resend = res;
        Node next;
        while (last.next != null)
            last = last.next;
        while (front != last) {
            if (last.data <= front.data) {
                resend.next = last;
                next = last.prev;
                last.prev.next = null;
                last.prev = resend;
                last = next;
                resend = resend.next;
            } else {
                resend.next = front;
                next = front.next;
                front.next = null;
                front.prev = resend;
                front = next;
                resend = resend.next;
            }
        }
        resend.next = front;
        front.prev = resend;
        return res.next;
    }
    static Node push(Node head_ref, int new_data) {
        Node new_node = new Node();
        new_node.data = new_data;
        new_node.prev = null;
        new_node.next = head_ref;
        if (head_ref != null)
            head_ref.prev = new_node;
        head_ref = new_node;
        return head_ref;
    }
    static void printList(Node head) {
        if (head == null)
            System.out.println("Doubly Linked list is empty"); 
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.next;
        }
    }
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Node head = null;
        int arr[] = new int[n];

        for (int i = 0; i < n; i++) {
            int m = sc.nextInt();
            head = push(head, m);
        }
        head = sort(head);
        System.out.println("After sorting:"); 
        printList(head);
    }
}

// 3. Segregate even and odd nodes
import java.util.*;
class Main {
    Node head;
    class Node {
        int data;
        Node next;
        Node(int d) {
            data = d;
            next = null;
        }
    }
    void segregateEvenOdd() {
        Node evenStart = null;
        Node evenEnd = null;
        Node oddStart = null;
        Node oddEnd = null;
        Node currentNode = head;
        while (currentNode != null) {
            int element = currentNode.data;
            if (element % 2 == 0) {
                if (evenStart == null) {
                    evenStart = currentNode;
                    evenEnd = evenStart;
                } else {
                    evenEnd.next = currentNode;
                    evenEnd = evenEnd.next;
                }
            } else {
                if (oddStart == null) {
                    oddStart = currentNode;
                    oddEnd = oddStart;
                } else {
                    oddEnd.next = currentNode;
                    oddEnd = oddEnd.next;
                }
            }
            currentNode = currentNode.next;
        }
        if (oddStart == null || evenStart == null) {
            return;
        }
        evenEnd.next = oddStart;
        oddEnd.next = null;
        head = evenStart;
    }
    void push(int new_data) {
        Node new_node = new Node(new_data);
        new_node.next = head;
        head = new_node;
    }
    void printList() {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println(); 
    }
    public static void main(String[] args) { 
        Main main = new Main();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for (int i = 0; i < n; i++) {
            int m = sc.nextInt();
            main.push(m);
        }
        main.segregateEvenOdd();
        main.printList();
    }
}

//4. Merge sort for DLL
import java.util.Scanner;
class Node {
    int data;
    Node next, prev;
    Node(int val) {
        data = val;
        next = null;
        prev = null;
    }
}
class Solution {
    public Node split(Node head) {
        Node fast = head, slow = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        Node temp = slow.next;
        slow.next = null;
        return temp;
    }
    public Node mergeSort(Node node) {
        if (node == null || node.next == null)
            return node;
        Node second = split(node);
        node = mergeSort(node);
        second = mergeSort(second);
        return merge(node, second);
    }
    public Node merge(Node first, Node second) {
        if (first == null)
            return second;
        if (second == null)
            return first;
        if (first.data < second.data) {
            first.next = merge(first.next, second);
            first.next.prev = first;
            first.prev = null;
            return first;
        } else {
            second.next = merge(first, second.next);
            second.next.prev = second;
            second.prev = null;
            return second;
        }
    }
}
public class Main {
    public static void printList_left_right(Node head) {
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.next;
        }
        System.out.println();
    }
    public static void printList_right_left(Node head) {
        Node tail = head;
        while (tail.next != null)
            tail = tail.next;
        while (tail != null) {
            System.out.print(tail.data + " ");
            tail = tail.prev;
        }
        System.out.println();
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int val = sc.nextInt();
        Node head = new Node(val);
        for (int i = 0; i < n; i++) {
            val = sc.nextInt();
            Node nd = new Node(val);
            nd.next = head;
            head = nd;
        }
        printList_left_right(head);
        printList_right_left(head);
    }
}

// 5. Minimum Stack 
import java.util.*;
class Mystack {
    Stack<Integer> s;
    Stack<Integer> a;
    Mystack() {
        s = new Stack<Integer>();
        a = new Stack<Integer>();
    }
    void getMin() {
        if (a.isEmpty())
            System.out.println("Stack is Empty");
        else
            System.out.println("Minimum element: " + a.peek());
    }
    void peek() {
        if (s.isEmpty()) {
            System.out.println("Stack is Empty");
            return;
        }
        int t = s.peek();
        System.out.println("Top most element: " + t);
    }
    void pop() {
        int t = s.pop();
        if (s.isEmpty()) {
            System.out.println("Stack is Empty");
            return;
        } else
            System.out.println("Removed element: " + t);
        if (t == a.peek())
            a.pop();
    }
    void push(int x) {
        if (s.isEmpty()) {
            s.push(x);
            a.push(x);
            System.out.println("Number Inserted: " + x);
            return;
        } else {
            s.push(x);
            System.out.println("Number Inserted: " + x);
        }
        if (x <= a.peek())
            a.push(x);
    }
}
public class Main {
    public static void main(String args[]) {
        Mystack s = new Mystack();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for (int i = 0; i < n; i++) {
            int m = sc.nextInt();
            s.push(m);
        }
        s.getMin();
        s.pop();
        s.getMin();
        s.pop();
        s.peek();
    }
}

//6. Celebrity problem
import java.util.*;
public class Main {
	public static int celebritySolution(int[][] mat) {
		Stack<Integer> stk = new Stack<>();
		for(int i=0;i<mat.length;i++)
		{
            	stk.push(i);
        	}
        	while(stk.size() > 1) {
            	int col = stk.pop();
            	int row = stk.pop();
            	if(mat[row][col] == 1)	{
                		stk.push(col); 
            	} 
			else 
			{
                		stk.push(row); 
            	}
        	}
        int x = stk.pop();
        for(int j=0;j<mat.length;j++) {
            if(j == x) continue;
            if(mat[x][j] == 1) {
                return -1;
            }
        }  
        for(int i=0;i<mat.length;i++) {
            if(i == x) continue;
            if(mat[i][x] == 0) {
                return -1;
            }
        }
        return x;
    }
public static void main(String[] args){
	Scanner sc=new Scanner(System.in);
	int n=sc.nextInt();
	int matrix[][]=new int[n][n];
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			matrix[i][j]=sc.nextInt();
	int res = celebritySolution(matrix);
      if(res == -1) 
		System.out.println("There is no celebrity in the party");
	else
		System.out.println(res + " is the celebrity in the party");
}
}

// 7. Tower of Hanoi
import java.util.*;
class Main {
    class Stack {
        int capacity;
        int top;
        int[] array;
        Stack(int capacity) {
            this.capacity = capacity;
            this.top = -1;
            this.array = new int[capacity];
        }
    }
    Stack createStack(int capacity) {
        return new Stack(capacity);
    }
    static boolean isFull(Stack stack) {
        return stack.top == stack.capacity - 1;
    }
    static boolean isEmpty(Stack stack) {
        return stack.top == -1;
    }
    static void push(Stack stack, int item) {
        if (isFull(stack))
            return;
        stack.array[++stack.top] = item;
    }
    static int pop(Stack stack) {
        if (isEmpty(stack))
            return Integer.MIN_VALUE;
        return stack.array[stack.top--];
    }
    static void move_disc(Stack source, Stack destination, char s, char d) {
        int p1 = pop(source);
        int p2 = pop(destination);
        if (p1 == Integer.MIN_VALUE) {
            push(source, p2);
            System.out.println("Move the disk " + p2 + " from " + d + " to " + s);
        } else if (p2 == Integer.MIN_VALUE) {
            push(destination, p1);
            System.out.println("Move the disk " + p1 + " from " + s + " to " + d);
        } else if (p1 > p2) {
            push(source, p1);
            push(source, p2);
            System.out.println("Move the disk " + p2 + " from " + d + " to " + s);
        } else {
            push(destination, p2);
            push(destination, p1);
            System.out.println("Move the disk " + p1 + " from " + s + " to " + d);
        }
    }
    public static void main(String[] args) {
        Scanner us = new Scanner(System.in);
        int num_of_disks = us.nextInt();
        Main ob = new Main();
        Stack source = ob.createStack(num_of_disks);
        Stack destination = ob.createStack(num_of_disks);
        Stack auxiliary = ob.createStack(num_of_disks);
        char s = 'S', d = 'D', a = 'A';
        if (num_of_disks % 2 == 0) {
            char temp = d;
            d = a;
            a = temp;
        }
        int total_num_of_moves = (int) (Math.pow(2, num_of_disks) - 1);
        for (int i = num_of_disks; i >= 1; i--)
            push(source, i);
        for (int i = 1; i <= total_num_of_moves; i++) {
            if (i % 3 == 1)
                move_disc(source, destination, s, d);
            else if (i % 3 == 2)
                move_disc(source, auxiliary, s, a);
            else if (i % 3 == 0)
                move_disc(auxiliary, destination, a, d);
        }
    }
}

// 8. Stock span problem
import java.util.*;
public class Main {
	static void calculate(int arr[], int n, int S[])
	{
		Stack<Integer> st = new Stack<>();
		st.push(0);
		S[0] = 1;
		for (int i = 1; i < n; i++) 
		{
			while (!st.isEmpty() && arr[st.peek()] <= arr[i])
				st.pop();
			S[i] = (st.isEmpty()) ? (i + 1) : (i - st.peek());
			st.push(i);
		}
	}
	static void printArray(int arr[]){
		System.out.print(Arrays.toString(arr));
	}
	public static void main(String[] args){
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int arr[]=new int [n];
		for(int i=0;i<n;i++)
			arr[i]=sc.nextInt();
		int S[] = new int[n];
		calculate(arr, n, S);
		printArray(S);
	}
}

// 9. Priority Queue using DLL
import java.util.*;
class Main {
    static class Node {
        int data;
        int priority;
        Node next, prev;
        public Node(int data, int priority) {
            this.data = data;
            this.priority = priority;
        }
    }
    private static Node head = null;
private static void push(int data, int priority) {
	if (head == null) {
		Node newNode = new Node(data, priority);
            head = newNode;
            return;  
	}
	Node node = new Node(data, priority);
        	Node temp = head, parent = null;
        	while (temp != null && temp.priority >= priority) {
            		parent = temp;
            		temp = temp.next;
        	}
       	if (parent == null) {
            		node.next = head;
            		head.prev = node;
            		head = node; } 
else if (temp == null) {
            parent.next = node;
            node.prev = parent;
}
else {
            parent.next = node;
            node.prev = parent;
            node.next = temp;
            temp.prev = node;
 } 
 }
 private static int peek() {
        	if (head != null) {
            		return head.data;
        	}
        	return -1; }
private static int pop() {
	if (head != null) {
		int curr = head.data;
         head = head.next;
		if (head != null)
			head.prev = null;
      return curr;
}
return -1;  
}
public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        for(int i=0;i<n;i++)
        {
            int data=sc.nextInt();
 				int pri=sc.nextInt(); 
				push(data, pri);
        		}
			System.out.println(peek());
        		System.out.println(pop());
        		System.out.println(pop());
        		System.out.println(peek());
	}
}

// 10. Sort without extra space
import java.util.*;
class Main
{ 
	public static int minIndex(Queue<Integer> list, int sortIndex) 
	{ 
	int min_index = -1; 
	int min_value = Integer.MAX_VALUE; 
	int s = list.size(); 
	for (int i = 0; i < s; i++) 
	{ 
		int current = list.peek(); 
		list.poll(); 
		if (current <= min_value && i <= sortIndex) 
		{ 
			min_index = i; 
			min_value = current; 
		} 
		list.add(current); 
	} 
	return min_index; 
} 
public static void insertMinToRear(Queue<Integer> list, int min_index) { 
		int min_value = 0; 
		int s = list.size(); 
		for (int i = 0; i < s; i++) 
		{ 
		int current = list.peek(); 
		list.poll(); 
		if (i != min_index) 
			list.add(current); 
		else
			min_value = current; 
		} 
		list.add(min_value); 
	} 
	public static void sortQueue(Queue<Integer> list) { 
		for(int i = 1; i <= list.size(); i++) 
		{ 
			int min_index = minIndex(list,list.size() - i); 
			insertMinToRear(list, min_index); 
		} 
	} 
public static void main (String[] args) 
	{ 
		Queue<Integer> list = new LinkedList<Integer>(); 
		list.add(6); 
		list.add(11); 
		list.add(15); 
		list.add(4);
		sortQueue(list); 
		while(list.isEmpty()== false) 
		{ 
			System.out.print(list.peek() + " "); 
			list.poll(); 
		} 
	} 
} 

// 11. Max sliding window

import java.util.*;
public class Main {
    public static int[] maxsliding(int[] in, int w) {
        int[] max_left = new int[in.length];
        int[] max_right = new int[in.length];
        max_left[0] = in[0];
        max_right[in.length - 1] = in[in.length - 1];
        for (int i = 1; i < in.length; i++) {
            max_left[i] = (i % w == 0) ? in[i] : Math.max(max_left[i - 1], in[i]);
            final int j = in.length - i - 1;
            max_right[j] = (j % w == 0) ? in[j] : Math.max(max_right[j + 1], in[j]);
        }
        final int[] sliding_max = new int[in.length - w + 1];
        for (int i = 0, j = 0; i + w <= in.length; i++) {
            sliding_max[j++] = Math.max(max_right[i], max_left[i + w - 1]);
        }
        return sliding_max;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        int ans[] = maxsliding(a, k);
        for (int i = 0; i < ans.length; i++)
            System.out.print(ans[i] + " ");
    }
}

// 12. Stack permutation
import java.util.*;
class Main {
	static Boolean check(int ip[], int op[], int n){
		Stack<Integer> s = new Stack<Integer>();
		int j = 0;
		for (int i = 0; i < n; i++) {
			s.push(ip[i]);
			while (!s.isEmpty() && s.peek() == op[j]) {
				s.pop();
				j++;
			}
		}
		if (s.isEmpty())
			return true;
		return false;
	}
	public static void main(String args[]){
		Scanner sc=new Scanner (System.in);
		int n=sc.nextInt();
		int input[]=new int[n];
		int output[]=new int[n];
		for(int i=0;i<n;i++)
            	input[i]=sc.nextInt();
		for(int i=0;i<n;i++)
            	output[i]=sc.nextInt();
		if (check(input, output, n))
			System.out.println("Yes");
		else
			System.out.println("Not Possible");
	}
}

// 13. Recover BTS
import java.util.Stack;
class TreeNode {
    int val;
    TreeNode left, right;
    // Constructor for TreeNode
    TreeNode(int x) {
        val = x;
    }
}
public class Solution {
    public void recoverTree(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;
        TreeNode lastProcessed = null;
        TreeNode firstElement = null;
        TreeNode secondElement = null;
        while (!stack.isEmpty() || current != null) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            current = stack.pop();
            if (lastProcessed != null && lastProcessed.val > current.val) {
                if (firstElement == null) {
                    firstElement = lastProcessed;
                }
                secondElement = current;
            }
            lastProcessed = current;
            current = current.right;
        }
        int temp = firstElement.val;
        firstElement.val = secondElement.val;
        secondElement.val = temp;
    }
    static void printInorder(TreeNode node) {
        if (node == null) return;
        printInorder(node.left);
        System.out.print(node.val + " ");
        printInorder(node.right);
    }
}

// 14. Views of tree
import java.util.*;
import java.util.Map.Entry;
class Node {
    int data, hd;
    Node left, right;
    public Node(int data) {
        this.data = data;
        left = right = null;
        this.hd = Integer.MAX_VALUE;
    }
}
class Main {
    static Node root;
    static Node build(String[] s) {
        if (s[0].equals("N") || s.length == 0)
            return null;
        Node root = new Node(Integer.parseInt(s[0]));
        Queue<Node> q = new LinkedList<>();
        q.add(root);
        int i = 1;
        while (!q.isEmpty() && i < s.length) {
            Node curr = q.poll();
            String cval = s[i];
            if (!cval.equals("N")) {
                int h = Integer.parseInt(cval);
                curr.left = new Node(h);
                q.add(curr.left);
            }
            i++;
            if (i >= s.length)
                break;
            cval = s[i];
            if (!cval.equals("N")) {
                int h = Integer.parseInt(cval);
                curr.right = new Node(h);
                q.add(curr.right);
            }
            i++;
        }
        return root;
    }
    void rightview(Node root) {
        if (root == null)
            return;
        Queue<Node> q = new LinkedList<>();
        q.add(root);
        while (!q.isEmpty()) {
            int n = q.size();
            for (int i = 0; i < n; i++) {
                Node curr = q.poll();
                if (i == n - 1) {
                    System.out.print(curr.data + " ");
                }
                if (curr.left != null)
                    q.add(curr.left);
                if (curr.right != null)
                    q.add(curr.right);
            }
        }
        System.out.println();
    }
    void leftview(Node root) {
        if (root == null)
            return;
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int n = queue.size();
            for (int i = 0; i < n; i++) {
                Node temp = queue.poll();
                if (i == 0)
                    System.out.print(temp.data + " ");
                if (temp.left != null)
                    queue.add(temp.left);
                if (temp.right != null)
                    queue.add(temp.right);
            }
        }
        System.out.println();
    }
    static void topview(Node root) {
        if (root == null)
            return;
        Queue<QueueObj> q = new LinkedList<>();
        Map<Integer, Integer> map = new TreeMap<>();
        q.add(new QueueObj(root, 0));
        while (!q.isEmpty()) {
            QueueObj curr = q.poll();
            if (!map.containsKey(curr.hd))
                map.put(curr.hd, curr.node.data);
            if (curr.node.left != null) {
                q.add(new QueueObj(curr.node.left, curr.hd - 1));
            }
            if (curr.node.right != null) {
                q.add(new QueueObj(curr.node.right, curr.hd + 1));
            }
        }
        for (Entry<Integer, Integer> entry : map.entrySet()) {
            System.out.print(entry.getValue() + " ");
        }
        System.out.println();
    }
    static void bottomview(Node root) {
        if (root == null)
            return;
        Queue<Node> queue = new LinkedList<>();
        Map<Integer, Integer> map = new TreeMap<>();
        root.hd = 0;
        queue.add(root);
        while (!queue.isEmpty()) {
            Node temp = queue.poll();
            int hd = temp.hd;
            map.put(hd, temp.data);
            if (temp.left != null) {
                temp.left.hd = hd - 1;
                queue.add(temp.left);
            }
            if (temp.right != null) {
                temp.right.hd = hd + 1;
                queue.add(temp.right);
            }
        }
        for (Entry<Integer, Integer> entry : map.entrySet()) {
            System.out.print(entry.getValue() + " ");
        }
        System.out.println();
    }
    static class QueueObj {
        Node node;
        int hd;

        QueueObj(Node node, int hd) {
            this.node = node;
            this.hd = hd;
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] s = sc.nextLine().split(" ");
        root = build(s);
        Main ob = new Main();
        ob.rightview(root);
        ob.leftview(root);
        ob.topview(root);
        ob.bottomview(root);
    }
}

// 15. Vertical order traversal
import java.util.*;
import java.util.Map.Entry;
class Node {
    int data;
    Node left, right;
    public Node(int data){
        this.data = data;
        left = right = null;
    }
}
class Main {
    static Node root;
    private List<Integer> path1 = new ArrayList<>();
    private List<Integer> path2 = new ArrayList<>();
    static Node build(String s[]){
        if(s[0]=="N"||s.length==0)
            return null;
        Node root=new Node(Integer.parseInt(s[0]));
	  Queue<Node> q=new LinkedList<Node>();
        q.add(root);
	     int i=1;
        while(!q.isEmpty() && i<s.length){
            Node curr=q.poll();
            String cval=s[i];
            if(!cval.equals("N")){
                int h=Integer.parseInt(cval);
                curr.left=new Node(h);
                q.add(curr.left);
            }
            i++;
            if(i >= s.length)
                break;
            cval = s[i];
               if(!cval.equals("N")){
                   int h=Integer.parseInt(cval);
                   curr.right=new Node(h);
                   q.add(curr.right);
               }
               i++;
           }
           return root;
	}
    static void preOrderTraversal(Node root, long hd, long vd,TreeMap<Long, Vector<Integer> > m){
        if (root == null)
            return;
        long val = hd << 30 | vd;
        if (m.get(val) != null)
            m.get(val).add(root.data);
        else {
            Vector<Integer> v = new Vector<Integer>();
            v.add(root.data);
            m.put(val, v);
        }
        preOrderTraversal(root.left, hd - 1, vd + 1, m);
        preOrderTraversal(root.right, hd + 1, vd + 1, m);
    }
    void verticalOrder(Node root){
        TreeMap<Long, Vector<Integer> > mp = new TreeMap<>();
        preOrderTraversal(root, 0, 1, mp);
        int prekey = Integer.MAX_VALUE;
	  for (Entry<Long, Vector<Integer> > entry :mp.entrySet()) {
            if(prekey!=Integer.MAX_VALUE && (entry.getKey()>>30)!= prekey)
                System.out.println();
            prekey = (int)(entry.getKey() >> 30);
            for (int x : entry.getValue())
                System.out.print(x + " ");
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int i;
        Main ob = new Main();
        String s[]=sc.nextLine().split(" ");
        root = build(s);
        ob.verticalOrder(root);
    }
}

// 16. BOUNDARY TRAVERSAL 
import java.util.*;
import java.util.Map.Entry;
class Node {
int data;
Node left, right;
public Node(int data) {
this.data = data;
left = right = null;
}
}
public class Main {
static Node root;
static Node build(String s[]) {
if (s[0].equals("N") || s.length == 0)
return null;
Node root = new Node(Integer.parseInt(s[0]));
Queue<Node> q = new LinkedList<Node>();
q.add(root);
int i = 1;
while (!q.isEmpty() && i < s.length) {
Node curr = q.poll();
String cval = s[i];
if (!cval.equals("N")) {
int h = Integer.parseInt(cval);
curr.left = new Node(h);
q.add(curr.left);
}
i++;
if (i >= s.length)
break;
cval = s[i];
if (!cval.equals("N")) {
int h = Integer.parseInt(cval);
curr.right = new Node(h);
q.add(curr.right);
}
i++;
}
return root;}
// print the leaves
void printLeaves(Node node) {
if (node == null)
return;
printLeaves(node.left);
if (node.left == null && node.right == null)
System.out.print(node.data + " ");
printLeaves(node.right);
}
// left boundary
void printBoundaryLeft(Node node) {
if (node == null)
return;
if (node.left != null) {
System.out.print(node.data + " ");
printBoundaryLeft(node.left);
} else if (node.right != null) {
System.out.print(node.data + " ");
printBoundaryLeft(node.right);
}
}
// right boundary
void printBoundaryRight(Node node) {
if (node == null)
return;
if (node.right != null) {
printBoundaryRight(node.right);
System.out.print(node.data + " ");
} else if (node.left != null) {
printBoundaryRight(node.left);
System.out.print(node.data + " ");
}
}
void printBoundary(Node node) {
if (node == null)
return;
System.out.print(node.data + " ");
printBoundaryLeft(node.left);
printLeaves(node.left);
printLeaves(node.right);
printBoundaryRight(node.right);
}
// main method
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
Main ob = new Main();
String s[] = sc.nextLine().split(" ");
root = build(s);
ob.printBoundary(root);
}
}

//17. K-ARY HEAP 
import java.util.*;
public class Main {
 public static void main(String[] args) {
 Scanner sc = new Scanner(System.in);
 int n = sc.nextInt();
 int k = sc.nextInt();
 int[] arr = new int[100];
 for (int i = 0; i < n; i++) {
 arr[i] = sc.nextInt();
 }
 buildHeap(arr, n, k);
 System.out.println("Built Heap: ");
 for (int i = 0; i < n; i++)
 System.out.print(arr[i] + " ");
 int element = 3;
 insert(arr, n, k, element);
 n++;
 System.out.println("\nHeap after insertion of " + element + ": ");
 for (int i = 0; i < n; i++)
 System.out.print(arr[i] + " ");
 System.out.println("\nExtracted max is " + extractMax(arr, n, k));
 n--;
 System.out.println("\nHeap after extract max: ");
 for (int i = 0; i < n; i++)
 System.out.print(arr[i] + " ");
 }
 public static void buildHeap(int[] arr, int n, int k) {
 for (int i = (n - 1) / k; i >= 0; i--)
 restoreDown(arr, n, i, k);
 }
 public static void insert(int[] arr, int n, int k, int elem) {
 if (n >= arr.length) {
 // Resize the array if it's full
 int[] newArr = new int[arr.length * 2];
 System.arraycopy(arr, 0, newArr, 0, arr.length);
 arr = newArr;
 }
 arr[n] = elem;
 restoreUp(arr, n, k);
}
 public static int extractMax(int[] arr, int n, int k) {
 int max = arr[0];
 arr[0] = arr[n - 1];
 restoreDown(arr, n - 1, 0, k);
 return max;
 }
 public static void restoreDown(int[] arr, int len, int index, int k) {
 int[] child = new int[k + 1];
 while (true) {
 for (int i = 1; i <= k; i++)
 child[i] = (k * index + i) < len ? (k * index + i) : -1;
 int maxChild = -1, maxChildIndex = 0;
 for (int i = 1; i <= k; i++) {
 if (child[i] != -1 && arr[child[i]] > maxChild) {
 maxChildIndex = child[i];
 maxChild = arr[child[i]];
 }
 }
 if (maxChild == -1)
 break;
 if (arr[index] < arr[maxChildIndex])
 swap(arr, index, maxChildIndex);
 index = maxChildIndex;
 }
 }
 public static void restoreUp(int[] arr, int index, int k) {
 int parent = (index - 1) / k;
 while (parent >= 0) {
 if (arr[index] > arr[parent]) {
 swap(arr, index, parent);
 index = parent;
 parent = (index - 1) / k;
 } else
 break;
 }
 }
 public static void swap(int[] arr, int i, int j) {
 int temp = arr[i];
 arr[i] = arr[j];
 arr[j] = temp;
 }
}

// 18. WINNER TREE 
import java.util.*;
class Node {
int idx;
Node left, right;
}
public class Main {
static Node createNode(int idx) {
Node t = new Node();
t.left = t.right = null;
t.idx = idx;
return t;
}
static void traverseHeight(Node root, int[] arr, int[] res) {
if (root == null || (root.left == null && root.right == null))
return;
if (res[0] > arr[root.left.idx] && root.left.idx != root.idx) {
res[0] = arr[root.left.idx];
traverseHeight(root.right, arr, res);
} else if (res[0] > arr[root.right.idx] && root.right.idx != root.idx) {
res[0] = arr[root.right.idx];
traverseHeight(root.left, arr, res);
}
}
static void findSecondMin(int[] arr, int n) {
List<Node> li = new LinkedList<>();
Node root = null;
for (int i = 0; i < n; i += 2) {
Node t1 = createNode(i);
Node t2 = null;
if (i + 1 < n) {
t2 = createNode(i + 1);
root = (arr[i] < arr[i + 1]) ? createNode(i) : createNode(i + 1);
root.left = t1;root.right = t2;
li.add(root);
} else
li.add(t1);
}
int lsize = li.size();
while (lsize != 1) {
int last = (lsize & 1) == 1 ? lsize - 2 : lsize - 1;
for (int i = 0; i < last; i += 2) {
Node f1 = li.remove(0);
Node f2 = li.remove(0);
root = (arr[f1.idx] < arr[f2.idx]) ? createNode(f1.idx) : createNode(f2.idx);
root.left = f1;
root.right = f2;
li.add(root);
}
if ((lsize & 1) == 1) {
li.add(li.get(0));
li.remove(0);
}
lsize = li.size();
}
int[] res = {Integer.MAX_VALUE};
traverseHeight(root, arr, res);
System.out.println("Minimum: " + arr[root.idx] + ", Second minimum: " + res[0]);
}
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
int n = s.nextInt();
int arr[] = new int[n];
for (int i = 0; i < n; i++)
arr[i] = s.nextInt();
findSecondMin(arr, n);
}
}

// 19. HEAP SORT 
import java.util.*;
public class Main {
public static void sort(int arr[]){
int N=arr.length;
for(int i=N/2-1; i>=0; i--)
heapify(arr,N,i);
for(int i=N-1; i>0; i--) {
int temp=arr[0];
arr[0]=arr[i];
arr[i]=temp;
heapify(arr,i,0);
}
}
static void heapify(int arr[], int N, int i){
int largest=i;
int l=2*i+1;
int r=2*i+2;
if(l<N && arr[l]>arr[largest])
largest=l;
if(r<N && arr[r]>arr[largest])
largest=r;if(largest!=i) {
int swap=arr[i];
arr[i]=arr[largest];
arr[largest]=swap;
heapify(arr,N,largest);
}
}
public static void main(String args[]){
Scanner s=new Scanner(System.in);
int n=s.nextInt();
int arr[] = new int[n];
for(int i=0; i<n; i++)
arr[i]=s.nextInt();
sort(arr);
System.out.println("Sorted array is");
for(int i=0; i<n; i++)
System.out.print(arr[i] + " ");
System.out.println();
}
}

// 20. TOPOLOGICAL ORDER 
import java.util.*;
class TopologicalSort {
// Graph coloring: 0->not visited...1->visited...2->visited & processed
private boolean detectCycleUtil(List<List<Integer>> adj, int[] visited, int v) {
if (visited[v] == 1)
return true;
if (visited[v] == 2)
return false;
visited[v] = 1; // Mark current as visited
for (int i = 0; i < adj.get(v).size(); ++i)
if (detectCycleUtil(adj, visited, adj.get(v).get(i)))
return true;
visited[v] = 2; // Mark current node as processed
return false;
}
// Cycle detection
private boolean detectCycle(List<List<Integer>> adj, int n) {
int[] visited = new int[n];
for (int i = 0; i < n; ++i)
if (visited[i] == 0)
if (detectCycleUtil(adj, visited, i))
return true;
return false;
}
// Topological sort
private void dfs(List<List<Integer>> adj, int v, boolean[] visited,
Stack<Integer> mystack) {
visited[v] = true;
for (int i = 0; i < adj.get(v).size(); ++i)
if (!visited[adj.get(v).get(i)])
dfs(adj, adj.get(v).get(i), visited, mystack);
mystack.push(v);
}
public int[] findOrder(int numCourses, int[][] prerequisites) {
List<List<Integer>> adj = new ArrayList<>();
for (int i = 0; i < numCourses; i++)
adj.add(new ArrayList<>());for (int i = 0; i < prerequisites.length; ++i)
adj.get(prerequisites[i][1]).add(prerequisites[i][0]);
int[] ans = new int[numCourses];
if (detectCycle(adj, numCourses))
return new int[0];
Stack<Integer> mystack = new Stack<>();
boolean[] visited = new boolean[numCourses];
for (int i = 0; i < numCourses; ++i)
if (!visited[i])
dfs(adj, i, visited, mystack);
int index = 0;
while (!mystack.isEmpty()) {
ans[index++] = mystack.pop();
}
return ans;
}
public static void main(String[] args) {
TopologicalSort solution = new TopologicalSort();
Scanner scanner = new Scanner(System.in);
System.out.print("Enter the number of courses: ");
int numCourses = scanner.nextInt();
System.out.print("Enter the number of prerequisites: ");
int n = scanner.nextInt();
int[][] prerequisites = new int[n][2];
System.out.println("Enter prerequisite pairs (course, prerequisite):");
for (int i = 0; i < n; i++) {
prerequisites[i][0] = scanner.nextInt();
prerequisites[i][1] = scanner.nextInt();
}
int[] result = solution.findOrder(numCourses, prerequisites);
System.out.println("Topological order of courses:");
System.out.println(Arrays.toString(result));
}
}

// 21. DIALS ALGORITM 
import java.util.*;
public class Graph {
static final int INF = Integer.MAX_VALUE;
private int V;
private ArrayList<ArrayList<Tuple> > adj;
public Graph(int v){
this.V = v;
this.adj = new ArrayList<ArrayList<Tuple> >();
for (int i = 0; i < v; i++)
this.adj.add(new ArrayList<Tuple>());
}
public void AddEdge(int u, int v, int w){
adj.get(u).add(new Tuple(v, w));
adj.get(v).add(new Tuple(u, w));
}
public void shortestPath(int src, int W){
int[] dist = new int[V];
Arrays.fill(dist, INF);
ArrayList<Integer>[] B = new ArrayList[W * V + 1];
for (int i = 0; i < W * V + 1; i++)
B[i] = new ArrayList<Integer>();
B[0].add(src);
dist[src] = 0;int idx = 0;
while (true) {
while (B[idx].size() == 0 && idx < W * V)
idx++;
if (idx == W * V)
break;
int u = B[idx].get(0);
B[idx].remove(0);
for (Tuple i : adj.get(u)) {
int v = i.v;
int weight = i.w;
int du = dist[u];
int dv = dist[v];
if (dv > du + weight) {
dist[v] = du + weight;
dv = dist[v];
B[dv].add(0, v);
}
}
}
System.out.println("Vertex Distance from Source");
for (int i = 0; i < V; ++i)
System.out.println(i + "\t\t" + dist[i]);
}
static class Tuple {
int v, w;
Tuple(int v, int w){
this.v = v;
this.w = w;
}
}
public static void main(String[] args){
Scanner s=new Scanner(System.in);
int V = s.nextInt();
Graph g = new Graph(V);
int e=s.nextInt();
int st,en,d;
for(int i=0; i<e; i++){
st=s.nextInt();
en=s.nextInt();
d=s.nextInt();
g.AddEdge(st,en,d);
}
g.shortestPath(0,e);
}
}

// 22. BELLMAN FORD ALGO 
import java.util.*;
class Main {
class Edge {
int src, dest, weight;
Edge(){
src = dest = weight = 0;
}
};
int V, E;
Edge edge[];
Main(int v, int e){V = v;
E = e;
edge = new Edge[e];
for (int i = 0; i < e; ++i)
edge[i] = new Edge();
}
void BellmanFord(Main graph, int src){
int V = graph.V, E = graph.E;
int dist[] = new int[V];
for (int i = 0; i < V; ++i)
dist[i] = Integer.MAX_VALUE;
dist[src] = 0;
for (int i = 1; i < V; ++i) {
for (int j = 0; j < E; ++j) {
int u = graph.edge[j].src;
int v = graph.edge[j].dest;
int weight = graph.edge[j].weight;
if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v])
dist[v] = dist[u] + weight;
}
}
for (int j = 0; j < E; ++j) {
int u = graph.edge[j].src;
int v = graph.edge[j].dest;
int weight = graph.edge[j].weight;
if(dist[u]!=Integer.MAX_VALUE && dist[u]+weight<dist[v]){
System.out.println(-1);
return;
}
}
for(int i = 0; i < V; ++i)
if(dist[i]!=Integer.MAX_VALUE)
System.out.print(dist[i]+" ");
else
System.out.print(-1+" ");
}
public static void main(String[] args){
Scanner sc=new Scanner(System.in);
int V = sc.nextInt();
int E = sc.nextInt();
Main graph = new Main(V,E);
for(int i=0;i<E;i++){
int u=sc.nextInt();
int v=sc.nextInt();
int w=sc.nextInt();
graph.edge[i].src = u;
graph.edge[i].dest = v;
graph.edge[i].weight = w;
}
graph.BellmanFord(graph, 0);
}
}
BFS-DFS 
import java.util.*;
class Node {
int num;
Node next;Node(int val) {
num = val;
next = null;
}
}
public class Main {
static Node insertNode(Node head, int val) {
Node newNode = new Node(val);
if (head == null) {
head = newNode;
return head;
}
Node temp = head;
while (temp.next != null)
temp = temp.next;
temp.next = newNode;
return head;
}
static void display(Node head) {
Node temp = head;
while (temp != null) {
System.out.print(temp.num + "->");
temp = temp.next;
}
System.out.println("NULL");
}
static void createCycle(Node head, int a, int b) {
if (head == null) return;
Node p1 = head;
Node p2 = head;
int cnta = 0, cntb = 0;
while (cnta != a || cntb != b) {
if (cnta != a && p1 != null) {
p1 = p1.next;
cnta++;
}
if (cntb != b && p2 != null) {
p2 = p2.next;
cntb++;
}
}
if (p2 != null)
p2.next = p1;
}
static boolean cycleDetect(Node head) {
if (head == null) return false;
Node fast = head;
Node slow = head;
while (fast != null && fast.next != null) {
fast = fast.next.next;
slow = slow.next;
if (fast == slow)
return true;
}return false;
}
public static void main(String args[]) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
Node head = null;
for (int i = 0; i < n; i++) {
int m = sc.nextInt();
head = insertNode(head, m);
}
display(head);
int a = sc.nextInt();
createCycle(head, 1, a); // creating cycle in the list
if (cycleDetect(head))
System.out.println("Cycle detected");
else
System.out.println("Cycle not detected");
}
}

// 23. BINOMIAL HEAP 
import java.util.*;
class BinomialHeapNode {
int key, degree;
BinomialHeapNode parent;
BinomialHeapNode sibling;
BinomialHeapNode child;
public BinomialHeapNode(int k){
key = k;
degree = 0;
parent = null;
sibling = null;
child = null;
}
public BinomialHeapNode reverse(BinomialHeapNode sibl){
BinomialHeapNode ret;
if (sibling != null)
ret = sibling.reverse(this);
else
ret = this;
sibling = sibl;
return ret;
}
public BinomialHeapNode findMinNode(){
BinomialHeapNode x = this, y = this;
int min = x.key;
while (x != null) {
if (x.key < min) {
y = x;
min = x.key;
}
x = x.sibling;
}
return y;
}
public BinomialHeapNode findANodeWithKey(int value){
BinomialHeapNode temp = this, node = null;
while (temp != null) {if (temp.key == value) {
node = temp;
break;
}
if (temp.child == null)
temp = temp.sibling;
else {
node = temp.child.findANodeWithKey(value);
if (node == null)
temp = temp.sibling;
else
break;
}
}
return node;
}
public int getSize(){
return (1 + ((child == null) ? 0 : child.getSize())+ ((sibling == null) ? 0 :
sibling.getSize()));
}
}
class BinomialHeap {
private BinomialHeapNode Nodes;
private int size;
public BinomialHeap(){
Nodes = null;
size = 0;
}
public boolean isEmpty() {
return Nodes == null;
}
public int getSize() {
return size;
}
public void makeEmpty(){
Nodes = null;
size = 0;
}
public void insert(int value){
if (value > 0) {
BinomialHeapNode temp = new BinomialHeapNode(value);
if (Nodes == null) {
Nodes = temp;
size = 1;
}
else {
unionNodes(temp);size++;
}
}
}
private void merge(BinomialHeapNode binHeap){
BinomialHeapNode temp1 = Nodes, temp2 = binHeap;
while ((temp1 != null) && (temp2 != null)) {
if (temp1.degree == temp2.degree) {
BinomialHeapNode tmp = temp2;
temp2 = temp2.sibling;
tmp.sibling = temp1.sibling;
temp1.sibling = tmp;
temp1 = tmp.sibling;
}else {
if (temp1.degree < temp2.degree) {
if ((temp1.sibling == null) || (temp1.sibling.degree > temp2.degree)){
BinomialHeapNode tmp = temp2;
temp2 = temp2.sibling;
tmp.sibling = temp1.sibling;
temp1.sibling = tmp;
temp1 = tmp.sibling;
}
else
temp1 = temp1.sibling;
}
else {
BinomialHeapNode tmp = temp1;
temp1 = temp2;
temp2 = temp2.sibling;
temp1.sibling = tmp;
if (tmp == Nodes)
Nodes = temp1;
}
}
}
if (temp1 == null) {
temp1 = Nodes;
while (temp1.sibling != null)
temp1 = temp1.sibling;
temp1.sibling = temp2;
}
}
private void unionNodes(BinomialHeapNode binHeap){
merge(binHeap);
BinomialHeapNode prevTemp = null, temp = Nodes, nextTemp =
Nodes.sibling;
while (nextTemp != null) {
if ((temp.degree != nextTemp.degree) || ((nextTemp.sibling != null) &&
(nextTemp.sibling.degree == temp.degree))){
prevTemp = temp;
temp = nextTemp;
}
else {
if (temp.key <= nextTemp.key) {
temp.sibling = nextTemp.sibling;
nextTemp.parent = temp;
nextTemp.sibling = temp.child;
temp.child = nextTemp;
temp.degree++;
}
else {
if (prevTemp == null)
Nodes = nextTemp;
else
prevTemp.sibling = nextTemp;
temp.parent = nextTemp;
temp.sibling = nextTemp.child;
nextTemp.child = temp;
nextTemp.degree++;
temp = nextTemp;
}
}
nextTemp = temp.sibling;}
}
public int findMinimum(){
return Nodes.findMinNode().key;
}
public void delete(int value){
if ((Nodes!=null) && (Nodes.findANodeWithKey(value)!=null)){
decreaseKeyValue(value, findMinimum() - 1);
extractMin();
}
}
public void decreaseKeyValue(int old_value,int new_value){
BinomialHeapNode temp = Nodes.findANodeWithKey(old_value);
if (temp == null)
return;
temp.key = new_value;
BinomialHeapNode tempParent = temp.parent;
while ((tempParent != null) && (temp.key < tempParent.key)) {
int z = temp.key;
temp.key = tempParent.key;
tempParent.key = z;
temp = tempParent;
tempParent = tempParent.parent;
}
}
public int extractMin(){
if (Nodes == null)
return -1;
BinomialHeapNode temp = Nodes, prevTemp = null;
BinomialHeapNode minNode = Nodes.findMinNode();
while (temp.key != minNode.key) {
prevTemp = temp;
temp = temp.sibling;
}
if (prevTemp == null)
Nodes = temp.sibling;
else
prevTemp.sibling = temp.sibling;
temp = temp.child;
BinomialHeapNode fakeNode = temp;
while (temp != null) {
temp.parent = null;
temp = temp.sibling;
}
if ((Nodes == null) && (fakeNode == null))
size = 0;
else {
if ((Nodes == null) && (fakeNode != null)) {
Nodes = fakeNode.reverse(null);
size = Nodes.getSize();
}
else {
if ((Nodes != null) && (fakeNode == null))
size = Nodes.getSize();
else {
unionNodes(fakeNode.reverse(null));
size = Nodes.getSize();
}
}
}return minNode.key;
}
public void displayHeap(){
System.out.print("\nHeap : ");displayHeap(Nodes);
System.out.println("\n");
}
private void displayHeap(BinomialHeapNode r){
if (r != null) {
displayHeap(r.child);System.out.print(r.key + " ");
displayHeap(r.sibling);
}
}
}
public class Main {
public static void main(String[] args){
BinomialHeap binHeap = new BinomialHeap();
Scanner s=new Scanner(System.in);
int n=s.nextInt();
for(int i=0; i<n; i++)
binHeap.insert(s.nextInt());
System.out.println("Size:" + binHeap.getSize());
binHeap.displayHeap();
binHeap.delete(s.nextInt());
System.out.println("Size:" + binHeap.getSize());
binHeap.displayHeap();
System.out.println(binHeap.isEmpty());
binHeap.makeEmpty();
System.out.println(binHeap.isEmpty());
}
}

//24. BFS
import java.util.*;
public class Main {
  private int V;
  private LinkedList<Integer> adj[];
  public Main(int v) {
    V = v;
    adj = new LinkedList[v];
    for (int i = 0; i < v; ++i)
      adj[i] = new LinkedList<Integer>();
  }
  void addEdge(int v, int w) {
    adj[v].add(w);
  }
  void BFS(int s) {
    boolean visited[] = new boolean[V];
    LinkedList<Integer> queue = new LinkedList<Integer>();
    visited[s] = true;
    queue.add(s);
    while (queue.size() != 0) {
      s = queue.poll();
      System.out.print(s + " "); // You can modify this line to perform actions on visited nodes
      Iterator<Integer> itr = adj[s].listIterator();
      while (itr.hasNext()) {
        int n = itr.next();
        if (!visited[n]) {
          visited[n] = true;
          queue.add(n);
        }
      }
    }
  }
  public static void main(String args[]) {
    Main g = new Main(4); 
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
    System.out.println("Following is Breadth First Traversal (starting from vertex 2)");
    g.BFS(2);
  }
}

//25. Hashmap to treemap
//Approach 1
import java.util.*; 
import java.util.stream.*; 
class Main {
    public static <K, V> Map<K, V> convertToTreeMap(Map<K, V> hashMap) 
    { 
        Map<K, V>treeMap = hashMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue, (oldValue, newValue) -> newValue, TreeMap::new)); 
        return treeMap; 
    } 
    public static void main(String args[]) 
    {
        Map<String, String> hashMap = new HashMap<>();
        Scanner s=new Scanner(System.in);
        int n=s.nextInt();
        for(int i=0; i<n; i++)
            hashMap.put(s.next(),s.next()); 
        System.out.println("HashMap: " + hashMap); 
        Map<String, String> treeMap = convertToTreeMap(hashMap); 
        System.out.println("TreeMap: " + treeMap); 
    } 
}
//Approach 2
import java.util.*; 
import java.util.stream.*; 
class Main { 
	public static <K, V> Map<K, V> convertToTreeMap(Map<K, V> hashMap) 
	{ 
		Map<K, V> treeMap = new TreeMap<>(); 
		treeMap.putAll(hashMap); 
		return treeMap; 
	} 
	public static void main(String args[]) 
	{ 
		Map<String, String> hashMap = new HashMap<>();
		Scanner s=new Scanner(System.in);
         int n=s.nextInt();
         for(int i=0; i<n; i++)
                hashMap.put(s.next(),s.next());
		System.out.println("HashMap: " + hashMap);
		Map<String, String> treeMap = convertToTreeMap(hashMap);
		System.out.println("TreeMap: " + treeMap); 
	} 
}
//Approach 3
import java.util.*; 
import java.util.stream.*; 
class Main { 
	public static Map<Integer, String> convertToTreeMap(Map<String, String> hashMap){ 
		Map<Integer, String> treeMap = new TreeMap<>(); 
		for (Map.Entry<String, String> e : hashMap.entrySet())
			treeMap.put(Integer.parseInt(e.getKey()), e.getValue()); 
		return treeMap; 
	} 
	public static void main(String args[]) {
		Map<String, String> hashMap = new HashMap<>();
		Scanner s=new Scanner(System.in);
        	int n=s.nextInt();
        	for(int i=0; i<n; i++)
            	hashMap.put(s.next(),s.next());
		System.out.println("HashMap: " + hashMap); 
		Map<Integer, String> treeMap = convertToTreeMap(hashMap); 
		System.out.println("TreeMap: " + treeMap); 
	} 
}

//26 Hashset Treeset LinkedlistHashSet
//Hashset :- Good performance
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Set < Integer > set1 = new HashSet < > ();
        //add
        set1.add(35);
        set1.add(12);
        set1.add(89);
        set1.add(18);
        set1.add(12);
        System.out.println("set1 : " + set1);
        //remove
        set1.remove(89);
        //contains
        System.out.println(set1.contains(35));
        for (Integer i: set1) {
            System.out.print(i + " ");
        }
        System.out.println();
        Set < Integer > set2 = new HashSet < > ();
        set2.add(4);
        set2.add(2);
        set2.add(5);
        set2.add(18);
        set2.addAll(set1);
        System.out.println(set2);
    }
}
//Treeset :- Sorted order or custom comparator
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Set < Integer > set1 = new TreeSet < > ();
        //add
        set1.add(35);
        set1.add(12);
        set1.add(89);
        set1.add(18);
        set1.add(12);
        System.out.println("set1 : " + set1);
        //remove
        set1.remove(89);
        //contains
        System.out.println(set1.contains(35));
        for (Integer i: set1) {
            System.out.print(i + " ");
        }
        System.out.println();
        Set < Integer > set2 = new TreeSet < > ();
        set2.add(4);
        set2.add(2);
        set2.add(5);
        set2.add(18);
        set2.addAll(set1);
        System.out.println(set2);
    }
}
//LinkedlistHashSet :- Maintain order of insertion + good preformance
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Set < Integer > set1 = new LinkedHashSet < > ();
        //add
        set1.add(35);
        set1.add(12);
        set1.add(89);
        set1.add(18);
        set1.add(12);
        System.out.println("set1 : " + set1);
        //remove
        set1.remove(89);
        //contains
        System.out.println(set1.contains(35));
        for (Integer i: set1) {
            System.out.print(i + " ");
        }
        System.out.println();
        Set < Integer > set2 = new LinkedHashSet < > ();
        set2.add(4);
        set2.add(2);
        set2.add(5);
        set2.add(18);
        set2.addAll(set1);
        System.out.println(set2);
    }
}

//27. Distributing items to a person
//cannot take more than 2 item for same type
import java.util.*;
public class Main {
	static boolean checkCount(int []arr, int n, int k){
		int count;
		for (int i = 0; i < n; i++){
			count = 0;
			for (int j = 0; j < n; j++){
				if (arr[j] == arr[i])count++;
				if (count > 2 * k)return false;
			}
		}return true;
	}
      static public void main (String[] args){
	      Scanner s=new Scanner(System.in);
	      int n=s.nextInt(); int k = s.nextInt();
		int []arr =new int[n];
		for(int i=0; i<n; i++)
		    arr[i]=s.nextInt();
		if(checkCount(arr, n, k)) System.out.println("Yes");
		else  System.out.println("No");
	}
}
//can take more than 2 item of a same type
import java.util.*
class Main{
	static boolean checkCount(int arr[], int n, int k) { 
		HashMap <Integer, Integer> hash = new HashMap<>(); 
		for (int i = 0; i < n; i++){
			if (!hash.containsKey(arr[i])) hash.put(arr[i], 0);
			hash.put(arr[i], hash.get(arr[i]) + 1);
		}
		for (Map.Entry x : hash.entrySet())
			if ((int)x.getValue() > 2 * k) return false; 
		return true; 
	} 
	public static void main(String []args){
	    Scanner s=new Scanner(System.in);
	    int n=s.nextInt();int k = s.nextInt();
		int []arr =new int[n];
		for(int i=0; i<n; i++)
		    arr[i]=s.nextInt();
		if (checkCount(arr, n, k)) System.out.println("Yes");
		else  System.out.println("No");
	}
}

//28 Fibonacci
//using recursion
import java.util.*;
public class Main{
    public static int memo_fib(int arr[], int n){
      if(arr[n] != -1)
            return arr[n];
      if(n <= 1)
            return n;
      arr[n] = memo_fib(arr, n-2) + memo_fib(arr, n-1);
      return arr[n];
    }
    public static int fib(int n){
    int arr[]=new int[n+1];
    for(int i = 0; i <= n; i++)
        arr[i] = -1;
    return memo_fib(arr, n);
    }
    public static void main(String[] args){
        Scanner s=new Scanner(System.in);
        int n=s.nextInt();
        System.out.print(fib(n));
    }
}
//using dynamic programming
import java.util.*;
public class Main{
    public static int fib(int n){ 
      int f[]=new int[n+1]; 
      int i; 
      f[0] = 0;   f[1] = 1;  
      for (i = 2; i <= n; i++) 
          f[i] = f[i-1] + f[i-2]; 
      return f[n]; 
    }
    public static void main(String[] args){
        Scanner s=new Scanner(System.in);
        int n=s.nextInt();
        System.out.print(fib(n));
    }
}

//29 Longest Common Subsequence
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String str1 = sc.next();
		String str2 = sc.next();
		Integer[][] dp = new Integer[str1.length()][str2.length()];
		System.out.println(helper(0, 0, str1, str2, dp));
	}
	public static int helper(int i, int j, String str1, String str2, Integer[][] dp) {
		if (i == str1.length() || j == str2.length())
			return 0;
		if (dp[i][j] != null)
			return dp[i][j];
		if (str1.charAt(i) == str2.charAt(j))
			return 1 + helper(i + 1, j + 1, str1, str2, dp);
		int first = helper(i + 1, j, str1, str2, dp);
		int second = helper(i, j + 1, str1, str2, dp);
		int answer = Math.max(first, second);
		dp[i][j] = answer;
		return answer;}}

//30 Longest Increasing Subsequence
import java.util.Scanner;
public class Main {
    public static int lis(int arr[],int n ){  
        int lis[]=new int[n]; 
        lis[0] = 1;    
        for(int i=1; i<n; i++){ 
            lis[i] = 1; 
            for(int j=0; j<i; j++)   
                if(arr[i]>arr[j] && lis[i]<lis[j]+1)  
                    lis[i]=lis[j]+1;  
        } 
        int m=Integer.MIN_VALUE;
        for(int i=0; i<n; i++)
            if(m<lis[i])
                m=lis[i];
        return m;
    }  
        public static void main(String[] args){ 
      Scanner s=new Scanner(System.in);
      int n=s.nextInt();
      int a[]=new int[n];
      for(int i=0;i<n;i++)
        a[i]=s.nextInt();
      System.out.print(lis(a,n));
    }
}

//31. Longest Bitonic Subsequence
import java.util.*;
public class Main{
    public static int lbs(int arr[],int n){  
       int lis[] = new int[n]; 
       for(int i=0; i<n; i++) 
          lis[i] = 1; 
       for(int i=1; i<n; i++) 
          for(int j=0; j<i; j++) 
             if(arr[i]>arr[j] && lis[i]<lis[j]+1) 
                lis[i]=lis[j]+1;
       int lds[] = new int [n]; 
       for(int i=0; i<n; i++) 
          lds[i]=1; 
       for(int i=n-2; i>=0; i--) 
          for(int j=n-1; j>i; j--) 
             if (arr[i]>arr[j] && lds[i]<lds[j]+1) 
                lds[i]=lds[j]+1; 
       int max=lis[0]+lds[0]-1; 
       for(int i=1; i<n; i++) 
         if(lis[i]+lds[i]-1>max) 
             max=lis[i]+lds[i]-1; 
       return max; }
public static void main(String args[]){
        Scanner s=new Scanner(System.in);
        int n=s.nextInt();
        int a[]=new int[n];
        for(int i=0; i<n; i++)
            a[i]=s.nextInt();
        System.out.print(lbs(a,n));
    }
}

//32 Longest Palindromic Subsequence
import java.util.Scanner;
public class Main {
	public static void main(String args[]) {
		Scanner sc = new Scanner(System.in);
		String s = sc.next();
		Integer[][] dp = new Integer[s.length()][s.length()];
		System.out.println(helper(0, s.length() - 1, s, dp));
	}
	public static int helper(int start,int end,String s,Integer[][] dp) {
		if (start>end)
			return 0;
		if (start==end)
			return 1;
		if (dp[start][end]!=null)
			return dp[start][end];
		if (s.charAt(start)==s.charAt(end))
			return dp[start][end]=2+helper(start+1,end-1,s,dp);
		return dp[start][end]=Math.max(helper(start+1,end,s,dp),helper(start,end-1,s,dp));

	}
}

//33. Subset Sum problem
import java.util.Scanner;
class Main {
	static boolean isSubsetSum(int set[], int n, int sum){
		if (sum == 0)
			return true;
		if (n == 0)
			return false;
		if (set[n - 1] > sum)
			return isSubsetSum(set, n - 1, sum);
		return isSubsetSum(set, n - 1, sum) || isSubsetSum(set, n - 1, sum - set[n - 1]);
	}
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int n =sc.nextInt();
		int sum = sc.nextInt();
		int set[]= new int[n];
		for(int i=0;i<n;i++)
			set[i]=sc.nextInt();
            if (isSubsetSum(set, n, sum) == true)
			System.out.println("yes");
		else
			System.out.println("no");
	}
}
